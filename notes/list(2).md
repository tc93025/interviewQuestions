## 前文回顾
1、缓存策略 FIFO先进先出 LFU最少使用 LRU最近最少使用
2、单链表 循环链表 双向链表
3、链表之于数组，更适合插入删除操作更多的结构，如ArrayList这样可以自动扩容的数组结构，在容量不够的时候需要将整个数组copy到新的内存空间。
4、链表实现LRU，a.如果数据已被缓存在链表中，遍历删除该节点，将数据存至链表头部。b.如果数据未缓存，且链表空间有富裕，插入链表头部。c.如果数据已缓存，删除尾部节点，插入链表头部
5、标记清除法，定时gc可以提高LRU算法效率
6、双向链表比单向时间复杂低一些的原因
```
实际开发中会有以下两种情况操作链表
操作节点中“值等于某个给定值”的节点
操作给定指针指向的节点
```
是当我们知道链表节点（情况2）的时候，双向链表可以直接得到节点的前驱后驱，直接操作O（1），而单向还是需要去遍历得知前置节点O（n）


## 如何轻松写出正确的链表代码

- 理解指针或者引用的含义：存储所指对象的内存地址。将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针可以找到这个变量。
- 警惕指针丢失和内存泄漏
- 哨兵 哨兵节点解决边界问题，不直接参与业务逻辑 有哨兵节点的列表叫带头链表 哨兵的意义在于减少特殊条件的判断，比如判断空、判断越界等 比如给一个哨兵节点，以及将key赋值给数组末元素让数组遍历不用判断越界也可以因为相等停下来
  ``` java
  // 在数组a中，查找key，返回key所在的位置
  // 其中，n表示数组a的长度
  int find(char* a, int n, char key) {
    // 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
    if(a == null || n <= 0) {
      return -1;
    }
    
    int i = 0;
    // 这里有两个比较操作：i<n和a[i]==key.
    while (i < n) {
      if (a[i] == key) {
        return i;
      }
      ++i;
    }
    
    return -1;
  }
  ```
  ``` java
  // 在数组a中，查找key，返回key所在的位置
  // 其中，n表示数组a的长度
  // 我举2个例子，你可以拿例子走一下代码
  // a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
  // a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
  int find(char* a, int n, char key) {
    if(a == null || n <= 0) {
      return -1;
    }
    
    // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
    if (a[n-1] == key) {
      return n-1;
    }
    
    // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
    // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
    char tmp = a[n-1];
    // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
    a[n-1] = key;
    
    int i = 0;
    // while 循环比起代码一，少了i<n这个比较操作
    while (a[i] != key) {
      ++i;
    }
    
    // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
    a[n-1] = tmp;
    
    if (i == n-1) {
      // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
      return -1;
    } else {
      // 否则，返回i，就是等于key值的元素的下标
      return i;
    }
  }
  ```
- 留意边界条件 如果链表为空，如果只有一个节点，如果只有两个节点，只处理头尾节点能否正常工作
- 画图与举例

- 练习题 
  ```
  单链表反转 leetcode 206、链表中环的检测 141、两个有序链表合并 21、删除链表倒数第n个节点 19、求链表的中间节点 876
  ```