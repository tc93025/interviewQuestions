## 正则分享

#### 基础语法 弄个表用来对照例题 回溯（分支与两次） 贪婪懒惰 捕获 零宽断言

##### 回溯
- 分支
- 继续分析上面那个案例。"Lalala. Hi, barret. Hello, John".match(/H(i|ello), barret/g),首先会查找 H 字符，在第九位找到 H 之后，正则子表达式提供了两个选择 (i|ello)，程序会先拿到最左边的那个分支，进入分支后，在第十位匹配到了 i，接着匹配下一个字符，下一个字符是逗号，接着刚才的位置又匹配到了这个逗号，然后再匹配下一个，依次类推，直到完整匹配到整个正则的内容，此时程序会在Hi, barret后面做一个标记，表示在这里进行了一次成功的匹配。但程序到此并没有结束，因为后面加了一个全局参数，依然使用这个分支往后匹配，很显然，到了 Hello 的时候，Hi 分支匹配不了了，于是程序会回溯到刚才我们做标记的位置，并进入第二个分支，从做标记的位置重新开始匹配，依次循环。

只要正则表达式没有尝试完所有的可选项，他就会回溯到最近的决策点（也就是上次匹配成功的位置）。
- 量词
- 量词这个概念特别简单，只是在匹配过程中有贪婪匹配和懒惰匹配两种模式，结合回溯的概念理解稍微复杂。还是用几个例子来说明。

1) 贪婪

``` javascript
  str = "AB1111BA111BA";
  reg = /AB[\s\S]+BA/;
  console.log(str.match(reg));
```
首先是匹配AB，遇到了 [\s\S]+，这是贪婪模式的匹配，他会一口吞掉后面所有的字符，也就是如果 reg 的内容为 AB[\s\S]+，那后面的就不用看了，直接全部匹配，而往后看，正则后面还有B字符，所以他会先回溯到倒数第一个字符，匹配看是否为 B，显然倒数第一个字符不是B，于是他又接着回溯，找到了B字母，找到之后就不继续回溯了，而是往后继续匹配，此刻匹配的是字符A，程序发现紧跟B后的字母确实是A，那此时匹配就结束了。如果没有看明白，可以再读读下面这个图：
```
  REG: /AB[\s\S]+BA/
  MATCH: A               匹配第一个字符
        AB              匹配第二个字符
        AB1111BA111BA   [\s\S]+ 贪婪吞并所有字符
        AB1111BA111BA   回溯，匹配字符B
        AB1111BA111B    找到字符B，继续匹配A
        AB1111BA111BA   找到字符A，匹配完成，停止匹配
```
2) 懒惰（非贪婪）

``` JavaScript
  str = "AB1111BA111BA";
  reg = /AB[\s\S]+?BA/;
  console.log(str.match(reg));
```
与上面不同的是，reg 中多了一个 ? 号，此时的匹配模式为懒惰模式，也叫做非贪婪匹配。此时的匹配流程是，先匹配AB，遇到[\s\S]+?，程序尝试跳过并开始匹配后面的字符B，往后查看的时候，发现是数字1，不是要匹配的内容，继续往后匹配，知道遇到字符B，然后匹配A，发现紧接着B后面就有一个A，于是宣布匹配完成，停止程序。

```
  REG: /AB[\s\S]+BA/
  MATCH: A               匹配第一个字符
        AB              匹配第二个字符
        AB              [\s\S]+? 非贪婪跳过并开始匹配B
        AB1             不是B，回溯，继续匹配
        AB11            不是B，回溯，继续匹配
        AB111           不是B，回溯，继续匹配
        AB1111          不是B，回溯，继续匹配
        AB1111B         找到字符B，继续匹配A
        AB1111BA        找到字符A，匹配完成，停止匹配
```
如果匹配的内容是 AB1111BA，那贪婪和非贪婪方式的正则是等价的，但是内部的匹配原理还是有区别的。为了高效运用正则，必须搞清楚使用正则时会遇到那些性能消耗问题。回溯失控问题。

##### 断言

(?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion) 
(?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion) 
(?<=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion) 
(?<!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion) 

- js的后行断言es2018引入

- 先行断言 后行断言
我爱你 我爱 爱 爱你

如果要取出爱字，要求这个爱字后面有你，这个时候就要这么写，这就是 先行断言：

'我爱你 我爱 爱 爱你'.match(/爱(?=你)/g) // ["爱", "爱"]

如果要求爱字后面没有你，那自然也有先行否定断言：

'我爱你 我爱 爱 爱你'.match(/爱(?!你)/g) // ["爱", "爱"] ，因为匹配相同...

这个时候，如果要求爱字后面有你，前面还要有我，那就要用到后行断言了，如下：

'我爱你 我爱 爱 爱你'.match(/(?<=我)爱(?=你)/g) // ["爱"]

最后，如果要求爱字前面没有我，后面也没有我，那就要用到先行否定断言和后行否定断言，如下：

'我爱你 我爱 爱 爱你'.match(/(?<!我)爱(?!你)/g) // ["爱"]
#### 例题 工作上遇到的 
- webpack配置 简单说
- 解析url上的参数，有单个解析，全解析
- 模版解析 vue的模版解析
- 遇到的路区编号匹配 引出性能问题
#### 性能问题 的来源 正则的实现引擎 DFA 回顾 贪婪
- 有限状态机（finite-state machine）也被称为有限状态自动机，状态机其实就是用图把状态和状态之间的关系描述出来，状态机中的一个状态可以在某些给定条件下变成另外一种状态
- https://zhuanlan.zhihu.com/p/138068681
- 其中NFA全称是非确定性有限状态自动机(Nondeterministic finite automaton)，DFA全称是确定性有限状态自动机(Deterministic finite automaton)。
- 总结下NFA和DFA的区别就是，有ε边或者某个节点对同一输入对应多个状态的一定是NFA。

- DFA和NFA存在等价性，也就是说任何NFA都可以转化为等价的DFA。由于NFA的非确定性，在面对一个输入的时候可能有多条可选的路径，所以在一条路径走不通的情况下，需要回溯到选择点去走另外一条路径。但DFA不同，在每个状态下，对每个输入不会存在多条路径，就不需要递归和回溯了，可以一条路走到黑。DFA的匹复杂度只有O(n)，但因为要递归和回溯NFA的匹配复杂度达到了O(n^2)。 这也是为什么我们要将引擎中的NFA转化为DFA的主要原因。
- https://xindoo.blog.csdn.net/article/details/106458165
- 现有Traditional NFA，POSIX NFA 和 DFA。

- 知道正则表达式引擎是如何工作的有助于你很快理解为何某个正则表达式不像你期望的那样工作。

有两种类型的引擎：文本导向(text-directed)的引擎和正则导向(regex-directed)的引擎。Jeffrey Friedl把他们称作DFA和NFA引擎。本文谈到的是正则导向的引擎。这是因为一些非常有用的特性，如“惰性”量词(lazy quantifiers)和反向引用(backreferences)，只能在正则导向的引擎中实现。所以毫不意外这种引擎是目前最流行的引擎。

你可以轻易分辨出所使用的引擎是文本导向还是正则导向。如果反向引用或“惰性”量词被实现，则可以肯定你使用的引擎是正则导向的。你可以作如下测试：将正则表达式<<regex|regex not>>应用到字符串“regex not”。如果匹配的结果是regex，则引擎是正则导向的。如果结果是regex not，则是文本导向的。因为正则导向的引擎是“猴急”的，它会很急切的进行表功，报告它找到的第一个匹配 。

 

·        正则导向的引擎总是返回最左边的匹配

这是需要你理解的很重要的一点：即使以后有可能发现一个“更好”的匹配，正则导向的引擎也总是返回最左边的匹配。

当把<<cat>>应用到“He captured a catfish for his cat”，引擎先比较<<c>>和“H”，结果失败了。于是引擎再比较<<c>>和“e”，也失败了。直到第四个字符，<<c>>匹配了“c”。<<a>>匹配了第五个字符。到第六个字符<<t>>没能匹配“p”，也失败了。引擎再继续从第五个字符重新检查匹配性。直到第十五个字符开始，<<cat>>匹配上了“catfish”中的“cat”，正则表达式引擎急切的返回第一个匹配的结果，而不会再继续查找是否有其他更好的匹配。

 - 用 /nfa|nfa not/ 去匹配 "nfa not"。
  如果匹配结果是 'nfa'，那这个就是Traditional NFA(传统型NFA)了。
  如果是 'nfa not'，那有可能是 POSIX NFA 也可能是 DFA。

  那我们先来试试这个正则吧。

  1
  console.log("nfa not".match(/nfa|nfa not/));
  得到的结果是 nfa，那么可以确定 js 的引擎是 传统型NFA 了。


  如果是 'nfa not'，那么要进行下一步测试来确定到底是 POSIX NFA 还是 DFA。
  /X(.+)+X/ 去匹配 "==XX============================="。
  如果执行时间长，则是 NFA (Traditional NFA在上一步已经可以确定了)。
  如果执行时间短，基本就是DFA，也可能是高级优化的NFA。
  另外，如果执行时溢出，超时，那也可以肯定是 NFA 了。

  
  ```
  为了有效地使用正则表达式，重要的是理解它们的工作原理。下面是一个正则表达式处理的基本步骤：
      第一步：编译
      当你创建了一个正则表达式对象之后（使用一个正则表达式直接量或者RegExp构造器），浏览器检查你的模板有没有错误，然后将它转换成一个本机代码例程，用于执行匹配工作。如果你将正则表达式赋给一个变量，你可以避免重复执行此步骤。
      第二步：设置起始位置

      当一个正则表达式投入使用时，首先要确定目标字符串中开始搜索的位置。它是字符串的起始位置，或由正则表达式的lastIndex属性指定，但是当它从第四步返回到这里的时候（因为尝试匹配失败），此位置将位于最后一次尝试起始位置推后一个字符的位置上。
      浏览器优化正则表达式引擎的办法是，在这一阶段中通过早期预测跳过一些不必要的工作。例如，如果一个正则表达式以^开头，IE 和Chrome通常判断在字符串起始位置上是否能够匹配，然后可避免愚蠢地搜索后续位置。另一个例子是匹配第三个字母是x的字符串，一个聪明的办法是先找到x，然后再将起始位置回溯两个字符。
      第三步：匹配每个正则表达式的字元
      正则表达式一旦找好起始位置，它将一个一个地扫描目标文本和正则表达式模板。当一个特定字元匹配失败时，正则表达式将试图回溯到扫描之前的位置上，然后进入正则表达式其他可能的路径上。
      第四步：匹配成功或失败
      如果在字符串的当前位置上发现一个完全匹配，那么正则表达式宣布成功。如果正则表达式的所有可能路径都尝试过了，但是没有成功地匹配，那么正则表达式引擎回到第二步，从字符串的下一个字符重新尝试。只有字符串中的每个字符（以及最后一个字符后面的位置）都经历了这样的过程之后，还没有成功匹配，那么正则表达式就宣布彻底失败。
      牢记这一过程将有助于您明智地判别那些影响正则表达式性能问题的类型。
  ```

  ``` java
  /**
	 * 检测字符串匹配正则表达式
	 * 
	 * @param s 匹配字符串
	 * @param p 正则表达式
	 * @return
	 */
	public static boolean isMatch(String s, String p) {
		List<Node> nodes = parse2Nodes(p);
		return isMatch(s, 0, nodes.get(0));
	}

	/**
	 * 深度优先匹配字符串
	 * 
	 * @param s 带匹配字符串
	 * @param index 字符下标
	 * @param node NFA模型
	 * @return
	 */
	public static boolean isMatch(String s, final int index, Node node) {
		if (index > s.length() - 1) {
			return false;
		}
		char c = s.charAt(index);
		/*
		 * 找到匹配的字符，匹配成功
		 */
		if (c == node.value || node.value == '.') {
			/*
			 * 字符指针移动到最后一位，状态机到达最终状态返回匹配成功
			 */
			if (s.length() - 1 == index && node.isTail) {
				return true;
			}
			/*
			 * 转换到下一个状态尝试匹配
			 */
			if (node.node != null) {
				if (isMatch(s, index + 1, node.node)) {
					return true;
				}
			}
			for (Node ln : node.linkNodes) {
				if (isMatch(s, index + 1, ln)) {
					return true;
				}
			}
		} else {
			/*
			 * 转换到下一个状态尝试匹配
			 */
			for (Node ln : node.linkNodes) {
				if (ln != node) {
					if (isMatch(s, index, ln)) {
						return true;
					}
				}
			}
		}
		/*
		 * 不满足匹配成功条件，回溯
		 */
		return false;
	}
  ```
#### 优化策略
这里说的正则表达式优化，主要是针对目前常用的NFA模式正则表达式
- 减少回溯（分支和贪婪）
- 正则在安全领域中最常见的用途是用来编写安全策略，比如WAF的拦截策略以及HIDS对应的webshell检测策略等。以下归纳了几点正则优化的策略：

a)  合理使用括号
当要捕获组的时候，使用非捕获型括号(?:)，这是写策略正则最常用的优化方法，因为使用(?:)可以匹配想要的内容，但不捕获到组里，可以节省资源，提高效率。

b)  使用非贪婪模式
尽量使用非贪婪模式，因为贪婪模式情况下，容易造成回溯。如果不确定使用哪种模式，优先考虑

c）使用字符组代替分支条件
使用[a-d]表示a~d之间的字母，而不是使用(a|b|c|d)

d)  谨慎用点号元字符，尽可能不用星号和加号这样的任意量词
例子： 要匹配 <12345>，其中<>中间是1-5位的数字

正常写法： <\d*>

优化写法： <\d{1,5}>

e）提取多选结构开头的相同字符
例如 the|this 改成th(?:e|is)

f）使用占有优先量词和固化分组
占有优先量词：

?+ *+ ++ {m,n}+

占有优先量词与匹配优先量词很相似，只是它们从来不会交还已经匹配的字符。

固化分组：

(?>...)     ...是指具体内容

固化分组的内容与正常的匹配并无区别，只是当匹配完括号中的内容后，括号中的备用状态会全部舍去。

g）始、行描点优化
能确定起止位置，使用^能提高匹配的速度。同理，使用$标记结尾，正则引擎则会从符合条件的长度处开始匹配，略过目标字符串中许多可能的字符。在写正则表达式时，应该将描点独立出来，例如“^(?:abc|123)”比“^123|^abc”效率高，而“^(abc)”比“(^abc)”效率更高。