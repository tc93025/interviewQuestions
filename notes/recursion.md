# 递归（recursion）
- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件


- 写出递推公式，找到终止条件

- 例题：有n个台阶，一次可以走一个台阶或者两个台阶，求一共有多少种走法
  ```
  递归公式：f(n)=f(n-1)+f(n-2)
  终止条件：f(1)=0 可以通过用更小的数值n=3的时候看看终止条件够不够用，f(3)=f(2)+f(1) f(2)=f(1)+f(0) f(1)=1 那么需要f(0)=1或者直接f(2)=2
  ```
  ``` javascript
  let depth = 0;
  function re(n){
    depth++
    if(n==1) return 1
    if(n==0) return 1
    return re(n-1)+re(n-2)
  }
  ```

  - 所以写递归代码的关键是找到如何将大问题分解成小问题的规律，并且基于此写出递推公式，然后敲定终止条件，最后将递推公式和终止条件翻译成代码
  - 其实我们不需要想清楚递归层级的关系和整个递归的流程，我们吧a问题分解为bcd，只需要假设bcd解决了，不需要管怎么解决，然后敲定bcd与a的联系即可，这就是递归公式
  

  - 可以用一个变量作为深度
  - 可以用一个散列表，前端是map保存f(3)计算结果，这样不用重复计算